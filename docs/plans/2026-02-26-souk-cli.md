# Souk CLI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a Rust CLI (`souk`) and library (`souk-core`) that replaces 13 shell scripts managing a Claude Code plugin marketplace — covering validation, plugin management, AI-powered reviews, and CI integration.

**Architecture:** Cargo workspace with two crates: `souk-core` (pure library, no CLI concerns, returns `Result<T, SoukError>`) and `souk` (thin CLI binary using clap, calls core, formats output via `Reporter`). All validation is deterministic native Rust. AI reviews use LLM HTTP APIs (Anthropic, OpenAI, Gemini). All marketplace mutations use RAII-based atomic backup/restore.

**Tech Stack:** Rust 2021 edition, clap 4 (derive), serde/serde_json, thiserror, semver, walkdir, tempfile, regex, colored, dialoguer, indicatif, reqwest (for LLM APIs), insta (snapshot testing)

**Spec Reference:** `discovery/SPEC.md` — 16 stories across 5 priority tiers
**Architecture Reference:** `PLAN.md` — repo structure, dependency table, command tree

---

## Phase 1: Workspace & Core Types (Stories 3, 4 partial)

### Task 1: Create Cargo Workspace Skeleton

**Files:**
- Create: `Cargo.toml` (workspace root)
- Create: `crates/souk-core/Cargo.toml`
- Create: `crates/souk-core/src/lib.rs`
- Create: `crates/souk/Cargo.toml`
- Create: `crates/souk/src/main.rs`

**Step 1: Create workspace root Cargo.toml**

```toml
[workspace]
resolver = "2"
members = ["crates/souk-core", "crates/souk"]

[workspace.package]
version = "0.1.0"
edition = "2021"
license = "MIT"
```

**Step 2: Create souk-core Cargo.toml**

```toml
[package]
name = "souk-core"
version.workspace = true
edition.workspace = true

[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
thiserror = "2"
semver = { version = "1", features = ["serde"] }
walkdir = "2"
tempfile = "3"
regex = "1"

[dev-dependencies]
insta = { version = "1", features = ["yaml"] }
```

**Step 3: Create souk-core/src/lib.rs**

```rust
pub mod error;
pub mod types;

pub use error::SoukError;
```

**Step 4: Create souk CLI Cargo.toml**

```toml
[package]
name = "souk"
version.workspace = true
edition.workspace = true

[[bin]]
name = "souk"
path = "src/main.rs"

[dependencies]
souk-core = { path = "../souk-core" }
clap = { version = "4", features = ["derive"] }
colored = "2"
serde_json = "1"

[dev-dependencies]
assert_cmd = "2"
predicates = "3"
insta = { version = "1", features = ["yaml"] }
tempfile = "3"
```

**Step 5: Create souk/src/main.rs**

```rust
fn main() {
    println!("souk v0.1.0");
}
```

**Step 6: Verify workspace compiles**

Run: `cargo build`
Expected: Compiles with no errors.

**Step 7: Commit**

```bash
git add Cargo.toml crates/
git commit -m "feat: create cargo workspace skeleton with souk-core and souk crates"
```

---

### Task 2: Define Error Types

**Files:**
- Create: `crates/souk-core/src/error.rs`
- Modify: `crates/souk-core/src/lib.rs`

**Step 1: Write error type tests**

Create: `crates/souk-core/src/error.rs`

```rust
use std::path::PathBuf;
use thiserror::Error;

/// Severity of a validation diagnostic.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Severity {
    Error,
    Warning,
}

/// A single validation finding.
#[derive(Debug, Clone)]
pub struct ValidationDiagnostic {
    pub severity: Severity,
    pub message: String,
    pub path: Option<PathBuf>,
    pub field: Option<String>,
}

impl ValidationDiagnostic {
    pub fn error(message: impl Into<String>) -> Self {
        Self {
            severity: Severity::Error,
            message: message.into(),
            path: None,
            field: None,
        }
    }

    pub fn warning(message: impl Into<String>) -> Self {
        Self {
            severity: Severity::Warning,
            message: message.into(),
            path: None,
            field: None,
        }
    }

    pub fn with_path(mut self, path: impl Into<PathBuf>) -> Self {
        self.path = Some(path.into());
        self
    }

    pub fn with_field(mut self, field: impl Into<String>) -> Self {
        self.field = Some(field.into());
        self
    }

    pub fn is_error(&self) -> bool {
        self.severity == Severity::Error
    }
}

/// The result of validating a plugin or marketplace.
#[derive(Debug)]
pub struct ValidationResult {
    pub diagnostics: Vec<ValidationDiagnostic>,
}

impl ValidationResult {
    pub fn new() -> Self {
        Self {
            diagnostics: Vec::new(),
        }
    }

    pub fn push(&mut self, diagnostic: ValidationDiagnostic) {
        self.diagnostics.push(diagnostic);
    }

    pub fn has_errors(&self) -> bool {
        self.diagnostics.iter().any(|d| d.is_error())
    }

    pub fn error_count(&self) -> usize {
        self.diagnostics.iter().filter(|d| d.is_error()).count()
    }

    pub fn warning_count(&self) -> usize {
        self.diagnostics
            .iter()
            .filter(|d| d.severity == Severity::Warning)
            .count()
    }

    pub fn merge(&mut self, other: ValidationResult) {
        self.diagnostics.extend(other.diagnostics);
    }
}

impl Default for ValidationResult {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Error)]
pub enum SoukError {
    #[error("Plugin not found: {0}")]
    PluginNotFound(String),

    #[error("Skill not found: {skill} in plugin {plugin}")]
    SkillNotFound { plugin: String, skill: String },

    #[error("Marketplace not found: searched upward from {0}")]
    MarketplaceNotFound(PathBuf),

    #[error("Marketplace already exists at {0}")]
    MarketplaceAlreadyExists(PathBuf),

    #[error("Plugin already exists in marketplace: {0}")]
    PluginAlreadyExists(String),

    #[error("Validation failed with {0} error(s)")]
    ValidationFailed(usize),

    #[error("Atomic operation failed, backup restored: {0}")]
    AtomicRollback(String),

    #[error("No LLM API key found. Set one of: ANTHROPIC_API_KEY, OPENAI_API_KEY, GEMINI_API_KEY")]
    NoApiKey,

    #[error("LLM API error: {0}")]
    LlmApiError(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("Semver error: {0}")]
    Semver(#[from] semver::Error),

    #[error("{0}")]
    Other(String),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn validation_result_tracks_errors_and_warnings() {
        let mut result = ValidationResult::new();
        result.push(ValidationDiagnostic::error("bad thing"));
        result.push(ValidationDiagnostic::warning("meh thing"));
        result.push(ValidationDiagnostic::error("another bad"));

        assert!(result.has_errors());
        assert_eq!(result.error_count(), 2);
        assert_eq!(result.warning_count(), 1);
    }

    #[test]
    fn validation_result_merge() {
        let mut a = ValidationResult::new();
        a.push(ValidationDiagnostic::error("a"));

        let mut b = ValidationResult::new();
        b.push(ValidationDiagnostic::warning("b"));

        a.merge(b);
        assert_eq!(a.diagnostics.len(), 2);
    }

    #[test]
    fn diagnostic_builder_pattern() {
        let d = ValidationDiagnostic::error("missing name")
            .with_path("/tmp/plugin")
            .with_field("name");

        assert!(d.is_error());
        assert_eq!(d.path.unwrap().to_str().unwrap(), "/tmp/plugin");
        assert_eq!(d.field.unwrap(), "name");
    }
}
```

**Step 2: Run tests**

Run: `cargo test -p souk-core`
Expected: 3 tests pass.

**Step 3: Commit**

```bash
git add crates/souk-core/src/error.rs crates/souk-core/src/lib.rs
git commit -m "feat: add error types, ValidationDiagnostic, and ValidationResult"
```

---

### Task 3: Define Serde Types

**Files:**
- Create: `crates/souk-core/src/types/mod.rs`
- Create: `crates/souk-core/src/types/marketplace.rs`
- Create: `crates/souk-core/src/types/plugin.rs`
- Create: `crates/souk-core/src/types/skill.rs`
- Create: `crates/souk-core/src/types/version_constraint.rs`
- Modify: `crates/souk-core/src/lib.rs`

**Step 1: Write tests for marketplace types**

Create: `crates/souk-core/src/types/marketplace.rs`

```rust
use serde::{Deserialize, Serialize};

/// A plugin entry in marketplace.json.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginEntry {
    pub name: String,
    pub source: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tags: Vec<String>,
}

/// The marketplace.json root document.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Marketplace {
    pub version: String,
    #[serde(default = "default_plugin_root", skip_serializing_if = "Option::is_none")]
    pub plugin_root: Option<String>,
    pub plugins: Vec<PluginEntry>,
}

fn default_plugin_root() -> Option<String> {
    Some("./plugins".to_string())
}

impl Marketplace {
    /// Returns the pluginRoot, defaulting to "./plugins" if not set.
    pub fn plugin_root(&self) -> &str {
        self.plugin_root
            .as_deref()
            .unwrap_or("./plugins")
    }

    /// Returns the normalized pluginRoot (always starts with "./").
    pub fn normalized_plugin_root(&self) -> String {
        let root = self.plugin_root();
        if root.starts_with("./") || root.starts_with('/') {
            root.to_string()
        } else {
            format!("./{root}")
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn deserialize_marketplace_json() {
        let json = r#"{
            "version": "0.1.0",
            "pluginRoot": "./plugins",
            "plugins": [
                {"name": "my-plugin", "source": "my-plugin", "tags": ["dev"]}
            ]
        }"#;
        let mp: Marketplace = serde_json::from_str(json).unwrap();
        assert_eq!(mp.version, "0.1.0");
        assert_eq!(mp.plugin_root(), "./plugins");
        assert_eq!(mp.plugins.len(), 1);
        assert_eq!(mp.plugins[0].name, "my-plugin");
        assert_eq!(mp.plugins[0].tags, vec!["dev"]);
    }

    #[test]
    fn default_plugin_root_when_missing() {
        let json = r#"{"version": "0.1.0", "plugins": []}"#;
        let mp: Marketplace = serde_json::from_str(json).unwrap();
        assert_eq!(mp.plugin_root(), "./plugins");
    }

    #[test]
    fn normalize_plugin_root_without_dot_slash() {
        let json = r#"{"version": "0.1.0", "pluginRoot": "plugins", "plugins": []}"#;
        let mp: Marketplace = serde_json::from_str(json).unwrap();
        assert_eq!(mp.normalized_plugin_root(), "./plugins");
    }

    #[test]
    fn serialize_round_trip() {
        let mp = Marketplace {
            version: "1.0.0".to_string(),
            plugin_root: Some("./plugins".to_string()),
            plugins: vec![PluginEntry {
                name: "test".to_string(),
                source: "test".to_string(),
                tags: vec![],
            }],
        };
        let json = serde_json::to_string_pretty(&mp).unwrap();
        let mp2: Marketplace = serde_json::from_str(&json).unwrap();
        assert_eq!(mp2.version, "1.0.0");
    }
}
```

**Step 2: Write plugin.json types**

Create: `crates/souk-core/src/types/plugin.rs`

```rust
use serde::{Deserialize, Serialize};

/// A plugin.json manifest.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginManifest {
    pub name: Option<serde_json::Value>,
    pub version: Option<serde_json::Value>,
    pub description: Option<serde_json::Value>,
    #[serde(default)]
    pub keywords: Vec<String>,
}

impl PluginManifest {
    /// Returns the name as a non-null string, or None.
    pub fn name_str(&self) -> Option<&str> {
        self.name.as_ref().and_then(|v| v.as_str())
    }

    /// Returns the version as a non-null string, or None.
    pub fn version_str(&self) -> Option<&str> {
        self.version.as_ref().and_then(|v| v.as_str())
    }

    /// Returns the description as a non-null string, or None.
    pub fn description_str(&self) -> Option<&str> {
        self.description.as_ref().and_then(|v| v.as_str())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn deserialize_plugin_json() {
        let json = r#"{
            "name": "my-plugin",
            "version": "1.0.0",
            "description": "A test plugin",
            "keywords": ["test", "dev"]
        }"#;
        let pm: PluginManifest = serde_json::from_str(json).unwrap();
        assert_eq!(pm.name_str(), Some("my-plugin"));
        assert_eq!(pm.version_str(), Some("1.0.0"));
        assert_eq!(pm.description_str(), Some("A test plugin"));
        assert_eq!(pm.keywords, vec!["test", "dev"]);
    }

    #[test]
    fn null_name_returns_none() {
        let json = r#"{"name": null, "version": "1.0.0", "description": "desc"}"#;
        let pm: PluginManifest = serde_json::from_str(json).unwrap();
        assert_eq!(pm.name_str(), None);
    }

    #[test]
    fn missing_fields_are_none() {
        let json = r#"{}"#;
        let pm: PluginManifest = serde_json::from_str(json).unwrap();
        assert_eq!(pm.name_str(), None);
        assert_eq!(pm.version_str(), None);
        assert_eq!(pm.description_str(), None);
    }
}
```

**Step 3: Write skill metadata types**

Create: `crates/souk-core/src/types/skill.rs`

```rust
/// Metadata extracted from a SKILL.md frontmatter.
#[derive(Debug, Clone)]
pub struct SkillMetadata {
    /// Directory name containing the skill.
    pub dir_name: String,
    /// Display name from frontmatter `name:` field, or dir_name as fallback.
    pub display_name: String,
    /// Full path to the skill directory.
    pub path: std::path::PathBuf,
}

/// Parse the `name:` field from YAML frontmatter in SKILL.md content.
///
/// Frontmatter is delimited by `---` at the start of the file.
pub fn parse_skill_name_from_frontmatter(content: &str) -> Option<String> {
    let mut lines = content.lines();

    // First line must be "---"
    if lines.next()?.trim() != "---" {
        return None;
    }

    for line in lines {
        let trimmed = line.trim();
        if trimmed == "---" {
            break;
        }
        if let Some(rest) = trimmed.strip_prefix("name:") {
            let name = rest.trim().trim_matches('"').trim_matches('\'');
            if !name.is_empty() {
                return Some(name.to_string());
            }
        }
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_frontmatter_name() {
        let content = "---\nname: commit-message\ndescription: test\n---\n# Content";
        assert_eq!(
            parse_skill_name_from_frontmatter(content),
            Some("commit-message".to_string())
        );
    }

    #[test]
    fn parse_frontmatter_quoted_name() {
        let content = "---\nname: \"my skill\"\n---\n";
        assert_eq!(
            parse_skill_name_from_frontmatter(content),
            Some("my skill".to_string())
        );
    }

    #[test]
    fn no_frontmatter() {
        let content = "# Just a heading\nNo frontmatter here.";
        assert_eq!(parse_skill_name_from_frontmatter(content), None);
    }

    #[test]
    fn frontmatter_without_name() {
        let content = "---\ndescription: test\n---\n";
        assert_eq!(parse_skill_name_from_frontmatter(content), None);
    }

    #[test]
    fn empty_name_returns_none() {
        let content = "---\nname: \n---\n";
        assert_eq!(parse_skill_name_from_frontmatter(content), None);
    }
}
```

**Step 4: Write version constraint types**

Create: `crates/souk-core/src/types/version_constraint.rs`

```rust
use regex::Regex;
use std::sync::LazyLock;

static VERSION_CONSTRAINT_RE: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(
        r"^(\*|[\^~]?[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?|[<>=]+[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?)$",
    )
    .unwrap()
});

/// Validate that a version constraint string matches the expected pattern.
///
/// Valid formats: `*`, `^x.y.z`, `~x.y.z`, `>=x.y.z`, `<=x.y.z`, `>x.y.z`, `<x.y.z`, `x.y.z`
/// All may have an optional prerelease suffix like `-alpha.1`.
pub fn is_valid_version_constraint(s: &str) -> bool {
    VERSION_CONSTRAINT_RE.is_match(s)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn valid_constraints() {
        let valid = [
            "*",
            "1.0.0",
            "^1.0.0",
            "~1.0.0",
            ">=1.0.0",
            "<=1.0.0",
            ">1.0.0",
            "<1.0.0",
            "^1.0.0-alpha.1",
            "1.2.3-beta",
        ];
        for v in valid {
            assert!(is_valid_version_constraint(v), "should be valid: {v}");
        }
    }

    #[test]
    fn invalid_constraints() {
        let invalid = [
            "",
            "latest",
            "1.0",
            "^1.0",
            ">>1.0.0",
            "1.0.0.0",
        ];
        for v in invalid {
            assert!(!is_valid_version_constraint(v), "should be invalid: {v}");
        }
    }
}
```

**Step 5: Wire up module tree**

Create: `crates/souk-core/src/types/mod.rs`

```rust
pub mod marketplace;
pub mod plugin;
pub mod skill;
pub mod version_constraint;

pub use marketplace::{Marketplace, PluginEntry};
pub use plugin::PluginManifest;
pub use skill::{parse_skill_name_from_frontmatter, SkillMetadata};
pub use version_constraint::is_valid_version_constraint;
```

Update `crates/souk-core/src/lib.rs`:

```rust
pub mod error;
pub mod types;

pub use error::{SoukError, ValidationDiagnostic, ValidationResult, Severity};
pub use types::*;
```

**Step 6: Run all tests**

Run: `cargo test -p souk-core`
Expected: All tests pass (error tests + type tests).

**Step 7: Commit**

```bash
git add crates/souk-core/src/
git commit -m "feat: add serde types for marketplace, plugin, skill, and version constraints"
```

---

### Task 4: Implement Marketplace Discovery

**Files:**
- Create: `crates/souk-core/src/discovery.rs`
- Modify: `crates/souk-core/src/lib.rs`

**Step 1: Write tests and implementation**

Create: `crates/souk-core/src/discovery.rs`

```rust
use std::path::{Path, PathBuf};

use crate::error::SoukError;
use crate::types::marketplace::Marketplace;

/// Configuration derived from discovering and reading marketplace.json.
#[derive(Debug, Clone)]
pub struct MarketplaceConfig {
    /// Absolute path to marketplace.json.
    pub marketplace_path: PathBuf,
    /// Absolute path to the project root (parent of the dir containing marketplace.json).
    pub project_root: PathBuf,
    /// Absolute path to the plugin root directory.
    pub plugin_root_abs: PathBuf,
    /// The parsed marketplace document.
    pub marketplace: Marketplace,
}

/// Discover marketplace.json by searching upward from `start_dir`.
///
/// Checks for `.claude-plugin/marketplace.json` in each directory,
/// stopping at a git root (`.git` directory/file) or filesystem root.
pub fn discover_marketplace(start_dir: &Path) -> Result<PathBuf, SoukError> {
    let mut current = start_dir
        .canonicalize()
        .map_err(|e| SoukError::Io(e))?;

    loop {
        let candidate = current.join(".claude-plugin").join("marketplace.json");
        if candidate.is_file() {
            return Ok(candidate);
        }

        // Stop at git root
        if current.join(".git").exists() {
            break;
        }

        // Move to parent
        match current.parent() {
            Some(parent) if parent != current => {
                current = parent.to_path_buf();
            }
            _ => break,
        }
    }

    Err(SoukError::MarketplaceNotFound(start_dir.to_path_buf()))
}

/// Load and resolve a marketplace configuration from a marketplace.json path.
pub fn load_marketplace_config(marketplace_path: &Path) -> Result<MarketplaceConfig, SoukError> {
    let marketplace_path = marketplace_path
        .canonicalize()
        .map_err(|e| SoukError::Io(e))?;

    let content = std::fs::read_to_string(&marketplace_path)?;
    let marketplace: Marketplace = serde_json::from_str(&content)?;

    // Project root is the parent of the directory containing marketplace.json.
    // marketplace.json lives inside .claude-plugin/, so project_root = grandparent.
    let claude_plugin_dir = marketplace_path
        .parent()
        .ok_or_else(|| SoukError::Other("Invalid marketplace path".into()))?;
    let project_root = claude_plugin_dir
        .parent()
        .ok_or_else(|| SoukError::Other("Invalid marketplace path".into()))?
        .to_path_buf();

    // Resolve plugin root
    let plugin_root_rel = marketplace.normalized_plugin_root();
    let plugin_root_abs = project_root.join(&plugin_root_rel).canonicalize().map_err(
        |_| {
            SoukError::Other(format!(
                "Plugin root directory not found: {}",
                project_root.join(&plugin_root_rel).display()
            ))
        },
    )?;

    Ok(MarketplaceConfig {
        marketplace_path,
        project_root,
        plugin_root_abs,
        marketplace,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn setup_marketplace(tmp: &TempDir) -> PathBuf {
        let claude_dir = tmp.path().join(".claude-plugin");
        std::fs::create_dir_all(&claude_dir).unwrap();
        let plugins_dir = tmp.path().join("plugins");
        std::fs::create_dir_all(&plugins_dir).unwrap();

        let mp_path = claude_dir.join("marketplace.json");
        std::fs::write(
            &mp_path,
            r#"{"version": "0.1.0", "pluginRoot": "./plugins", "plugins": []}"#,
        )
        .unwrap();
        mp_path
    }

    #[test]
    fn discover_from_project_root() {
        let tmp = TempDir::new().unwrap();
        let mp_path = setup_marketplace(&tmp);
        let found = discover_marketplace(tmp.path()).unwrap();
        assert_eq!(found, mp_path.canonicalize().unwrap());
    }

    #[test]
    fn discover_from_subdirectory() {
        let tmp = TempDir::new().unwrap();
        setup_marketplace(&tmp);
        let sub = tmp.path().join("plugins").join("my-plugin");
        std::fs::create_dir_all(&sub).unwrap();

        let found = discover_marketplace(&sub).unwrap();
        assert!(found.ends_with("marketplace.json"));
    }

    #[test]
    fn discover_not_found() {
        let tmp = TempDir::new().unwrap();
        // Create .git to stop upward search
        std::fs::create_dir(tmp.path().join(".git")).unwrap();
        let result = discover_marketplace(tmp.path());
        assert!(result.is_err());
    }

    #[test]
    fn load_marketplace_config_resolves_paths() {
        let tmp = TempDir::new().unwrap();
        let mp_path = setup_marketplace(&tmp);
        let config = load_marketplace_config(&mp_path).unwrap();
        assert_eq!(config.project_root, tmp.path().canonicalize().unwrap());
        assert!(config.plugin_root_abs.ends_with("plugins"));
    }

    #[test]
    fn load_marketplace_config_default_plugin_root() {
        let tmp = TempDir::new().unwrap();
        let claude_dir = tmp.path().join(".claude-plugin");
        std::fs::create_dir_all(&claude_dir).unwrap();
        let plugins_dir = tmp.path().join("plugins");
        std::fs::create_dir_all(&plugins_dir).unwrap();
        let mp_path = claude_dir.join("marketplace.json");
        std::fs::write(&mp_path, r#"{"version": "0.1.0", "plugins": []}"#).unwrap();

        let config = load_marketplace_config(&mp_path).unwrap();
        assert!(config.plugin_root_abs.ends_with("plugins"));
    }
}
```

**Step 2: Wire up in lib.rs**

Add `pub mod discovery;` to `crates/souk-core/src/lib.rs`.

**Step 3: Run tests**

Run: `cargo test -p souk-core -- discovery`
Expected: All discovery tests pass.

**Step 4: Commit**

```bash
git add crates/souk-core/src/discovery.rs crates/souk-core/src/lib.rs
git commit -m "feat: add marketplace discovery with upward directory search"
```

---

### Task 5: Implement Plugin Resolution

**Files:**
- Create: `crates/souk-core/src/resolution/mod.rs`
- Create: `crates/souk-core/src/resolution/plugin.rs`
- Modify: `crates/souk-core/src/lib.rs`

**Step 1: Write plugin resolution with tests**

Create: `crates/souk-core/src/resolution/plugin.rs`

```rust
use std::path::{Path, PathBuf};

use crate::discovery::MarketplaceConfig;
use crate::error::SoukError;
use crate::types::marketplace::Marketplace;

/// Resolve a plugin input to an absolute filesystem path.
///
/// 3-tier resolution:
/// 1. Direct path: if input is an existing directory
/// 2. pluginRoot-relative: try `{plugin_root_abs}/{input}`
/// 3. Marketplace lookup: search `.plugins[].name` for a match, resolve source
pub fn resolve_plugin(
    input: &str,
    config: Option<&MarketplaceConfig>,
) -> Result<PathBuf, SoukError> {
    // Tier 1: Direct path
    let direct = PathBuf::from(input);
    if direct.is_dir() {
        return direct
            .canonicalize()
            .map_err(|e| SoukError::Io(e));
    }

    if let Some(config) = config {
        // Tier 2: pluginRoot-relative
        let relative = config.plugin_root_abs.join(input);
        if relative.is_dir() {
            return relative
                .canonicalize()
                .map_err(|e| SoukError::Io(e));
        }

        // Tier 3: Marketplace name lookup
        if let Some(entry) = config
            .marketplace
            .plugins
            .iter()
            .find(|p| p.name == input)
        {
            let resolved = resolve_source(&entry.source, config)?;
            if resolved.is_dir() {
                return resolved
                    .canonicalize()
                    .map_err(|e| SoukError::Io(e));
            }
        }
    }

    Err(SoukError::PluginNotFound(input.to_string()))
}

/// Resolve a marketplace source value to an absolute path.
///
/// - Starts with `/`: absolute path
/// - Starts with `./` or `../`: relative to project root
/// - Bare name: `{pluginRoot}/{name}`
pub fn resolve_source(
    source: &str,
    config: &MarketplaceConfig,
) -> Result<PathBuf, SoukError> {
    if source.starts_with('/') {
        Ok(PathBuf::from(source))
    } else if source.starts_with("./") || source.starts_with("../") {
        Ok(config.project_root.join(source))
    } else {
        Ok(config.plugin_root_abs.join(source))
    }
}

/// Convert an absolute plugin path back to a marketplace source string.
///
/// If under pluginRoot, returns `{normalized_plugin_root}/{dirname}`.
/// If outside pluginRoot, returns the absolute path.
pub fn plugin_path_to_source(
    path: &Path,
    config: &MarketplaceConfig,
) -> (String, bool) {
    let canon_path = path.canonicalize().unwrap_or_else(|_| path.to_path_buf());
    let canon_root = &config.plugin_root_abs;

    if let Ok(relative) = canon_path.strip_prefix(canon_root) {
        let dir_name = relative
            .components()
            .next()
            .map(|c| c.as_os_str().to_string_lossy().to_string())
            .unwrap_or_default();
        (dir_name, true)
    } else {
        (canon_path.to_string_lossy().to_string(), false)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::discovery::load_marketplace_config;
    use tempfile::TempDir;

    fn setup(tmp: &TempDir) -> MarketplaceConfig {
        let claude_dir = tmp.path().join(".claude-plugin");
        std::fs::create_dir_all(&claude_dir).unwrap();
        let plugins_dir = tmp.path().join("plugins");
        std::fs::create_dir_all(&plugins_dir).unwrap();

        // Create a plugin
        let plugin_dir = plugins_dir.join("my-plugin").join(".claude-plugin");
        std::fs::create_dir_all(&plugin_dir).unwrap();
        std::fs::write(
            plugin_dir.join("plugin.json"),
            r#"{"name": "my-plugin", "version": "1.0.0", "description": "test"}"#,
        )
        .unwrap();

        let mp_path = claude_dir.join("marketplace.json");
        std::fs::write(
            &mp_path,
            r#"{
                "version": "0.1.0",
                "pluginRoot": "./plugins",
                "plugins": [
                    {"name": "My Plugin", "source": "my-plugin"}
                ]
            }"#,
        )
        .unwrap();

        load_marketplace_config(&mp_path).unwrap()
    }

    #[test]
    fn resolve_by_direct_path() {
        let tmp = TempDir::new().unwrap();
        let config = setup(&tmp);
        let plugin_path = tmp.path().join("plugins").join("my-plugin");
        let result = resolve_plugin(plugin_path.to_str().unwrap(), Some(&config));
        assert!(result.is_ok());
    }

    #[test]
    fn resolve_by_plugin_root_relative() {
        let tmp = TempDir::new().unwrap();
        let config = setup(&tmp);
        let result = resolve_plugin("my-plugin", Some(&config));
        assert!(result.is_ok());
    }

    #[test]
    fn resolve_by_marketplace_name() {
        let tmp = TempDir::new().unwrap();
        let config = setup(&tmp);
        let result = resolve_plugin("My Plugin", Some(&config));
        assert!(result.is_ok());
    }

    #[test]
    fn resolve_not_found() {
        let tmp = TempDir::new().unwrap();
        let config = setup(&tmp);
        let result = resolve_plugin("nonexistent", Some(&config));
        assert!(matches!(result, Err(SoukError::PluginNotFound(_))));
    }

    #[test]
    fn path_to_source_internal() {
        let tmp = TempDir::new().unwrap();
        let config = setup(&tmp);
        let path = config.plugin_root_abs.join("my-plugin");
        let (source, is_internal) = plugin_path_to_source(&path, &config);
        assert_eq!(source, "my-plugin");
        assert!(is_internal);
    }

    #[test]
    fn path_to_source_external() {
        let tmp = TempDir::new().unwrap();
        let config = setup(&tmp);
        let external = TempDir::new().unwrap();
        let (source, is_internal) =
            plugin_path_to_source(external.path(), &config);
        assert!(!is_internal);
        assert!(source.starts_with('/'));
    }
}
```

**Step 2: Wire up module tree**

Create: `crates/souk-core/src/resolution/mod.rs`

```rust
pub mod plugin;

pub use plugin::{resolve_plugin, resolve_source, plugin_path_to_source};
```

Add `pub mod resolution;` to `crates/souk-core/src/lib.rs`.

**Step 3: Run tests**

Run: `cargo test -p souk-core -- resolution`
Expected: All resolution tests pass.

**Step 4: Commit**

```bash
git add crates/souk-core/src/resolution/
git commit -m "feat: add 3-tier plugin resolution"
```

---

### Task 6: Implement Skill Resolution

**Files:**
- Create: `crates/souk-core/src/resolution/skill.rs`
- Modify: `crates/souk-core/src/resolution/mod.rs`

**Step 1: Write skill resolution with tests**

Create: `crates/souk-core/src/resolution/skill.rs`

```rust
use std::path::{Path, PathBuf};

use crate::error::SoukError;
use crate::types::skill::{parse_skill_name_from_frontmatter, SkillMetadata};

/// Resolve a skill input to a skill directory path.
///
/// 3-tier resolution:
/// 1. Direct path: if input is a directory containing SKILL.md
/// 2. Skills subdirectory: try `{plugin_path}/skills/{input}/SKILL.md`
/// 3. Frontmatter name match: scan all skills, match `name:` field
pub fn resolve_skill(
    plugin_path: &Path,
    input: &str,
) -> Result<PathBuf, SoukError> {
    let plugin_name = plugin_path
        .file_name()
        .map(|n| n.to_string_lossy().to_string())
        .unwrap_or_default();

    // Tier 1: Direct path
    let direct = PathBuf::from(input);
    if direct.is_dir() && direct.join("SKILL.md").is_file() {
        return direct.canonicalize().map_err(SoukError::Io);
    }

    // Tier 2: Skills subdirectory
    let skills_dir = plugin_path.join("skills").join(input);
    if skills_dir.is_dir() && skills_dir.join("SKILL.md").is_file() {
        return skills_dir.canonicalize().map_err(SoukError::Io);
    }

    // Tier 3: Frontmatter name match
    let skills_parent = plugin_path.join("skills");
    if skills_parent.is_dir() {
        if let Ok(entries) = std::fs::read_dir(&skills_parent) {
            for entry in entries.flatten() {
                let skill_md = entry.path().join("SKILL.md");
                if skill_md.is_file() {
                    if let Ok(content) = std::fs::read_to_string(&skill_md) {
                        if let Some(name) = parse_skill_name_from_frontmatter(&content) {
                            if name == input {
                                return entry
                                    .path()
                                    .canonicalize()
                                    .map_err(SoukError::Io);
                            }
                        }
                    }
                }
            }
        }
    }

    Err(SoukError::SkillNotFound {
        plugin: plugin_name,
        skill: input.to_string(),
    })
}

/// Enumerate all skills in a plugin.
///
/// Scans `{plugin_path}/skills/*/SKILL.md` and extracts metadata.
pub fn enumerate_skills(plugin_path: &Path) -> Vec<SkillMetadata> {
    let skills_dir = plugin_path.join("skills");
    let mut skills = Vec::new();

    if !skills_dir.is_dir() {
        return skills;
    }

    let Ok(entries) = std::fs::read_dir(&skills_dir) else {
        return skills;
    };

    let mut entries: Vec<_> = entries.flatten().collect();
    entries.sort_by_key(|e| e.file_name());

    for entry in entries {
        let skill_md = entry.path().join("SKILL.md");
        if !skill_md.is_file() {
            continue;
        }

        let dir_name = entry
            .file_name()
            .to_string_lossy()
            .to_string();

        let display_name = std::fs::read_to_string(&skill_md)
            .ok()
            .and_then(|content| parse_skill_name_from_frontmatter(&content))
            .unwrap_or_else(|| dir_name.clone());

        skills.push(SkillMetadata {
            dir_name,
            display_name,
            path: entry.path(),
        });
    }

    skills
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn setup_plugin_with_skills(tmp: &TempDir) -> PathBuf {
        let plugin = tmp.path().join("my-plugin");
        let skills = plugin.join("skills");

        // Skill with frontmatter name
        let commit = skills.join("git-commit");
        std::fs::create_dir_all(&commit).unwrap();
        std::fs::write(
            commit.join("SKILL.md"),
            "---\nname: commit-message\ndescription: test\n---\n# Commit",
        )
        .unwrap();

        // Skill without frontmatter name
        let review = skills.join("code-review");
        std::fs::create_dir_all(&review).unwrap();
        std::fs::write(review.join("SKILL.md"), "# Code Review\nNo frontmatter.").unwrap();

        plugin
    }

    #[test]
    fn resolve_by_dir_name() {
        let tmp = TempDir::new().unwrap();
        let plugin = setup_plugin_with_skills(&tmp);
        let result = resolve_skill(&plugin, "git-commit");
        assert!(result.is_ok());
    }

    #[test]
    fn resolve_by_frontmatter_name() {
        let tmp = TempDir::new().unwrap();
        let plugin = setup_plugin_with_skills(&tmp);
        let result = resolve_skill(&plugin, "commit-message");
        assert!(result.is_ok());
        assert!(result.unwrap().ends_with("git-commit"));
    }

    #[test]
    fn resolve_not_found() {
        let tmp = TempDir::new().unwrap();
        let plugin = setup_plugin_with_skills(&tmp);
        let result = resolve_skill(&plugin, "nonexistent");
        assert!(matches!(result, Err(SoukError::SkillNotFound { .. })));
    }

    #[test]
    fn enumerate_returns_all_skills() {
        let tmp = TempDir::new().unwrap();
        let plugin = setup_plugin_with_skills(&tmp);
        let skills = enumerate_skills(&plugin);
        assert_eq!(skills.len(), 2);

        // Should be sorted by dir name
        assert_eq!(skills[0].dir_name, "code-review");
        assert_eq!(skills[0].display_name, "code-review"); // no frontmatter name

        assert_eq!(skills[1].dir_name, "git-commit");
        assert_eq!(skills[1].display_name, "commit-message"); // from frontmatter
    }

    #[test]
    fn enumerate_empty_skills() {
        let tmp = TempDir::new().unwrap();
        let plugin = tmp.path().join("no-skills");
        std::fs::create_dir_all(&plugin).unwrap();
        let skills = enumerate_skills(&plugin);
        assert!(skills.is_empty());
    }
}
```

**Step 2: Wire up module**

Update `crates/souk-core/src/resolution/mod.rs`:

```rust
pub mod plugin;
pub mod skill;

pub use plugin::{resolve_plugin, resolve_source, plugin_path_to_source};
pub use skill::{resolve_skill, enumerate_skills};
```

**Step 3: Run tests**

Run: `cargo test -p souk-core -- skill`
Expected: All skill tests pass.

**Step 4: Commit**

```bash
git add crates/souk-core/src/resolution/skill.rs crates/souk-core/src/resolution/mod.rs
git commit -m "feat: add 3-tier skill resolution and enumeration"
```

---

### Task 7: Implement Plugin Validation

**Files:**
- Create: `crates/souk-core/src/validation/mod.rs`
- Create: `crates/souk-core/src/validation/plugin.rs`
- Create: `crates/souk-core/src/validation/extends.rs`
- Modify: `crates/souk-core/src/lib.rs`

**Step 1: Write extends-plugin.json validation**

Create: `crates/souk-core/src/validation/extends.rs`

```rust
use std::path::Path;

use crate::error::{ValidationDiagnostic, ValidationResult};
use crate::types::version_constraint::is_valid_version_constraint;

const ALLOWED_KEYS: &[&str] = &[
    "dependencies",
    "optionalDependencies",
    "systemDependencies",
    "optionalSystemDependencies",
];

/// Validate an extends-plugin.json file.
///
/// Returns Ok with empty result if file doesn't exist (optional file).
pub fn validate_extends_plugin(plugin_path: &Path) -> ValidationResult {
    let mut result = ValidationResult::new();
    let extends_path = plugin_path
        .join(".claude-plugin")
        .join("extends-plugin.json");

    if !extends_path.is_file() {
        return result; // Optional file, skip
    }

    // V1.9: Valid JSON
    let content = match std::fs::read_to_string(&extends_path) {
        Ok(c) => c,
        Err(e) => {
            result.push(
                ValidationDiagnostic::error(format!("Cannot read extends-plugin.json: {e}"))
                    .with_path(&extends_path),
            );
            return result;
        }
    };

    let doc: serde_json::Value = match serde_json::from_str(&content) {
        Ok(v) => v,
        Err(e) => {
            result.push(
                ValidationDiagnostic::error(format!("Invalid JSON in extends-plugin.json: {e}"))
                    .with_path(&extends_path),
            );
            return result;
        }
    };

    let Some(obj) = doc.as_object() else {
        result.push(
            ValidationDiagnostic::error("extends-plugin.json must be a JSON object")
                .with_path(&extends_path),
        );
        return result;
    };

    // V1.10: Only allowed top-level keys
    for key in obj.keys() {
        if !ALLOWED_KEYS.contains(&key.as_str()) {
            result.push(
                ValidationDiagnostic::error(format!(
                    "Invalid key in extends-plugin.json: {key}"
                ))
                .with_path(&extends_path)
                .with_field(key.clone()),
            );
        }
    }

    // V1.11 + V1.12: Each section must be an object with valid version constraints
    for section_name in ALLOWED_KEYS {
        if let Some(section) = obj.get(*section_name) {
            if section.is_null() {
                continue;
            }
            let Some(section_obj) = section.as_object() else {
                result.push(
                    ValidationDiagnostic::error(format!(
                        "Invalid {section_name} in extends-plugin.json: expected object, got {}",
                        value_type_name(section)
                    ))
                    .with_path(&extends_path)
                    .with_field(section_name.to_string()),
                );
                continue;
            };

            for (dep_name, dep_value) in section_obj {
                let version = extract_version(dep_value);
                match version {
                    Some(v) => {
                        if !is_valid_version_constraint(&v) {
                            result.push(
                                ValidationDiagnostic::error(format!(
                                    "Invalid version constraint in {section_name}: {v} (for {dep_name})"
                                ))
                                .with_path(&extends_path)
                                .with_field(format!("{section_name}.{dep_name}")),
                            );
                        }
                    }
                    None => {
                        result.push(
                            ValidationDiagnostic::error(format!(
                                "Invalid dependency value in {section_name}: must be string or object with version (for {dep_name})"
                            ))
                            .with_path(&extends_path)
                            .with_field(format!("{section_name}.{dep_name}")),
                        );
                    }
                }
            }
        }
    }

    result
}

fn extract_version(value: &serde_json::Value) -> Option<String> {
    if let Some(s) = value.as_str() {
        Some(s.to_string())
    } else if let Some(obj) = value.as_object() {
        Some(
            obj.get("version")
                .and_then(|v| v.as_str())
                .unwrap_or("*")
                .to_string(),
        )
    } else {
        None
    }
}

fn value_type_name(v: &serde_json::Value) -> &'static str {
    match v {
        serde_json::Value::Array(_) => "array",
        serde_json::Value::Bool(_) => "boolean",
        serde_json::Value::Number(_) => "number",
        serde_json::Value::String(_) => "string",
        serde_json::Value::Null => "null",
        serde_json::Value::Object(_) => "object",
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn write_extends(tmp: &TempDir, content: &str) -> std::path::PathBuf {
        let plugin = tmp.path().join("test-plugin");
        let claude = plugin.join(".claude-plugin");
        std::fs::create_dir_all(&claude).unwrap();
        std::fs::write(claude.join("extends-plugin.json"), content).unwrap();
        plugin
    }

    #[test]
    fn valid_extends() {
        let tmp = TempDir::new().unwrap();
        let plugin = write_extends(&tmp, r#"{
            "dependencies": {"foo": "^1.0.0"},
            "optionalDependencies": {"bar": {"version": "~2.0.0"}},
            "systemDependencies": {"baz": "*"}
        }"#);
        let result = validate_extends_plugin(&plugin);
        assert!(!result.has_errors());
    }

    #[test]
    fn missing_file_is_ok() {
        let tmp = TempDir::new().unwrap();
        let result = validate_extends_plugin(tmp.path());
        assert!(!result.has_errors());
    }

    #[test]
    fn invalid_json() {
        let tmp = TempDir::new().unwrap();
        let plugin = write_extends(&tmp, "not json");
        let result = validate_extends_plugin(&plugin);
        assert!(result.has_errors());
    }

    #[test]
    fn invalid_top_level_key() {
        let tmp = TempDir::new().unwrap();
        let plugin = write_extends(&tmp, r#"{"badKey": {}}"#);
        let result = validate_extends_plugin(&plugin);
        assert!(result.has_errors());
        assert!(result.diagnostics[0].message.contains("Invalid key"));
    }

    #[test]
    fn section_must_be_object() {
        let tmp = TempDir::new().unwrap();
        let plugin = write_extends(&tmp, r#"{"dependencies": ["not", "an", "object"]}"#);
        let result = validate_extends_plugin(&plugin);
        assert!(result.has_errors());
        assert!(result.diagnostics[0].message.contains("expected object"));
    }

    #[test]
    fn invalid_version_constraint() {
        let tmp = TempDir::new().unwrap();
        let plugin = write_extends(&tmp, r#"{"dependencies": {"foo": "latest"}}"#);
        let result = validate_extends_plugin(&plugin);
        assert!(result.has_errors());
        assert!(result.diagnostics[0].message.contains("Invalid version constraint"));
    }

    #[test]
    fn object_value_without_version_defaults_to_star() {
        let tmp = TempDir::new().unwrap();
        let plugin = write_extends(&tmp, r#"{"dependencies": {"foo": {"notes": "optional"}}}"#);
        let result = validate_extends_plugin(&plugin);
        assert!(!result.has_errors()); // defaults to *, which is valid
    }

    #[test]
    fn non_string_non_object_value() {
        let tmp = TempDir::new().unwrap();
        let plugin = write_extends(&tmp, r#"{"dependencies": {"foo": 42}}"#);
        let result = validate_extends_plugin(&plugin);
        assert!(result.has_errors());
        assert!(result.diagnostics[0].message.contains("must be string or object"));
    }
}
```

**Step 2: Write plugin validation**

Create: `crates/souk-core/src/validation/plugin.rs`

```rust
use std::path::Path;

use crate::error::{ValidationDiagnostic, ValidationResult};
use crate::types::plugin::PluginManifest;
use crate::validation::extends::validate_extends_plugin;

/// Validate a plugin directory (deterministic, pure Rust, no external calls).
///
/// Checks (V1.1–V1.12 from spec):
/// 1. Path exists and is a directory
/// 2. `.claude-plugin/` directory exists
/// 3. `.claude-plugin/plugin.json` exists
/// 4. `plugin.json` is valid JSON
/// 5. `name` field exists and is non-null string
/// 6. `version` field exists and is non-null string
/// 7. `description` field exists and is non-null string
/// 8. `version` is valid semver
/// 9–12. extends-plugin.json validation (delegated)
pub fn validate_plugin(plugin_path: &Path) -> ValidationResult {
    let mut result = ValidationResult::new();

    // V1.1: Path exists and is a directory
    if !plugin_path.is_dir() {
        result.push(
            ValidationDiagnostic::error(format!(
                "Plugin path does not exist or is not a directory: {}",
                plugin_path.display()
            ))
            .with_path(plugin_path),
        );
        return result; // Can't continue
    }

    let claude_dir = plugin_path.join(".claude-plugin");

    // V1.2: .claude-plugin/ directory exists
    if !claude_dir.is_dir() {
        result.push(
            ValidationDiagnostic::error("Missing .claude-plugin directory")
                .with_path(plugin_path),
        );
        return result;
    }

    let plugin_json_path = claude_dir.join("plugin.json");

    // V1.3: plugin.json exists
    if !plugin_json_path.is_file() {
        result.push(
            ValidationDiagnostic::error("Missing plugin.json")
                .with_path(&claude_dir),
        );
        return result;
    }

    // V1.4: Valid JSON
    let content = match std::fs::read_to_string(&plugin_json_path) {
        Ok(c) => c,
        Err(e) => {
            result.push(
                ValidationDiagnostic::error(format!("Cannot read plugin.json: {e}"))
                    .with_path(&plugin_json_path),
            );
            return result;
        }
    };

    let manifest: PluginManifest = match serde_json::from_str(&content) {
        Ok(m) => m,
        Err(e) => {
            result.push(
                ValidationDiagnostic::error(format!("Invalid JSON in plugin.json: {e}"))
                    .with_path(&plugin_json_path),
            );
            return result;
        }
    };

    // V1.5: name field
    if manifest.name_str().is_none() {
        result.push(
            ValidationDiagnostic::error("Missing or null required field: name")
                .with_path(&plugin_json_path)
                .with_field("name"),
        );
    }

    // V1.6: version field
    let version_str = manifest.version_str();
    if version_str.is_none() {
        result.push(
            ValidationDiagnostic::error("Missing or null required field: version")
                .with_path(&plugin_json_path)
                .with_field("version"),
        );
    }

    // V1.7: description field
    if manifest.description_str().is_none() {
        result.push(
            ValidationDiagnostic::error("Missing or null required field: description")
                .with_path(&plugin_json_path)
                .with_field("description"),
        );
    }

    // V1.8: version is valid semver
    if let Some(v) = version_str {
        if semver::Version::parse(v).is_err() {
            result.push(
                ValidationDiagnostic::error(format!("Invalid semver version: {v}"))
                    .with_path(&plugin_json_path)
                    .with_field("version"),
            );
        }
    }

    // V1.9–V1.12: extends-plugin.json
    let extends_result = validate_extends_plugin(plugin_path);
    result.merge(extends_result);

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn make_valid_plugin(tmp: &TempDir) -> std::path::PathBuf {
        let plugin = tmp.path().join("good-plugin");
        let claude = plugin.join(".claude-plugin");
        std::fs::create_dir_all(&claude).unwrap();
        std::fs::write(
            claude.join("plugin.json"),
            r#"{"name": "good-plugin", "version": "1.0.0", "description": "A good plugin"}"#,
        )
        .unwrap();
        plugin
    }

    #[test]
    fn valid_plugin_passes() {
        let tmp = TempDir::new().unwrap();
        let plugin = make_valid_plugin(&tmp);
        let result = validate_plugin(&plugin);
        assert!(!result.has_errors(), "diagnostics: {:?}", result.diagnostics);
    }

    #[test]
    fn nonexistent_path() {
        let result = validate_plugin(Path::new("/tmp/nonexistent-plugin-xyz"));
        assert!(result.has_errors());
        assert!(result.diagnostics[0].message.contains("does not exist"));
    }

    #[test]
    fn missing_claude_plugin_dir() {
        let tmp = TempDir::new().unwrap();
        let plugin = tmp.path().join("bare-dir");
        std::fs::create_dir_all(&plugin).unwrap();
        let result = validate_plugin(&plugin);
        assert!(result.has_errors());
        assert!(result.diagnostics[0].message.contains(".claude-plugin"));
    }

    #[test]
    fn missing_plugin_json() {
        let tmp = TempDir::new().unwrap();
        let plugin = tmp.path().join("no-json");
        std::fs::create_dir_all(plugin.join(".claude-plugin")).unwrap();
        let result = validate_plugin(&plugin);
        assert!(result.has_errors());
        assert!(result.diagnostics[0].message.contains("plugin.json"));
    }

    #[test]
    fn invalid_json() {
        let tmp = TempDir::new().unwrap();
        let plugin = tmp.path().join("bad-json");
        let claude = plugin.join(".claude-plugin");
        std::fs::create_dir_all(&claude).unwrap();
        std::fs::write(claude.join("plugin.json"), "not json").unwrap();
        let result = validate_plugin(&plugin);
        assert!(result.has_errors());
    }

    #[test]
    fn missing_required_fields() {
        let tmp = TempDir::new().unwrap();
        let plugin = tmp.path().join("empty-fields");
        let claude = plugin.join(".claude-plugin");
        std::fs::create_dir_all(&claude).unwrap();
        std::fs::write(claude.join("plugin.json"), r#"{}"#).unwrap();
        let result = validate_plugin(&plugin);
        assert_eq!(result.error_count(), 3); // name, version, description
    }

    #[test]
    fn null_name() {
        let tmp = TempDir::new().unwrap();
        let plugin = tmp.path().join("null-name");
        let claude = plugin.join(".claude-plugin");
        std::fs::create_dir_all(&claude).unwrap();
        std::fs::write(
            claude.join("plugin.json"),
            r#"{"name": null, "version": "1.0.0", "description": "desc"}"#,
        )
        .unwrap();
        let result = validate_plugin(&plugin);
        assert!(result.has_errors());
        assert!(result.diagnostics.iter().any(|d| d.field.as_deref() == Some("name")));
    }

    #[test]
    fn invalid_semver() {
        let tmp = TempDir::new().unwrap();
        let plugin = tmp.path().join("bad-version");
        let claude = plugin.join(".claude-plugin");
        std::fs::create_dir_all(&claude).unwrap();
        std::fs::write(
            claude.join("plugin.json"),
            r#"{"name": "test", "version": "not.semver", "description": "desc"}"#,
        )
        .unwrap();
        let result = validate_plugin(&plugin);
        assert!(result.has_errors());
        assert!(result.diagnostics.iter().any(|d| d.message.contains("semver")));
    }

    #[test]
    fn valid_plugin_with_extends() {
        let tmp = TempDir::new().unwrap();
        let plugin = make_valid_plugin(&tmp);
        std::fs::write(
            plugin.join(".claude-plugin").join("extends-plugin.json"),
            r#"{"dependencies": {"foo": "^1.0.0"}}"#,
        )
        .unwrap();
        let result = validate_plugin(&plugin);
        assert!(!result.has_errors());
    }
}
```

**Step 3: Wire up module**

Create: `crates/souk-core/src/validation/mod.rs`

```rust
pub mod extends;
pub mod plugin;

pub use plugin::validate_plugin;
pub use extends::validate_extends_plugin;
```

Add `pub mod validation;` to `crates/souk-core/src/lib.rs`.

**Step 4: Run tests**

Run: `cargo test -p souk-core -- validation`
Expected: All validation tests pass.

**Step 5: Commit**

```bash
git add crates/souk-core/src/validation/
git commit -m "feat: add deterministic plugin validation (V1.1-V1.12)"
```

---

### Task 8: Implement Marketplace Validation

**Files:**
- Create: `crates/souk-core/src/validation/marketplace.rs`
- Modify: `crates/souk-core/src/validation/mod.rs`

**Step 1: Write marketplace validation with tests**

Create: `crates/souk-core/src/validation/marketplace.rs`

```rust
use std::collections::HashSet;
use std::path::Path;

use crate::discovery::MarketplaceConfig;
use crate::error::{ValidationDiagnostic, ValidationResult};
use crate::validation::plugin::validate_plugin;

/// Validate a marketplace.json and optionally all listed plugins.
///
/// Checks (V2.1–V2.11 from spec).
pub fn validate_marketplace(
    config: &MarketplaceConfig,
    skip_plugins: bool,
) -> ValidationResult {
    let mut result = ValidationResult::new();
    let mp = &config.marketplace;

    // V2.4: version is valid semver
    if semver::Version::parse(&mp.version).is_err() {
        result.push(
            ValidationDiagnostic::error(format!(
                "Invalid marketplace version: {}",
                mp.version
            ))
            .with_path(&config.marketplace_path)
            .with_field("version"),
        );
    }

    // V2.5: pluginRoot points to existing directory (already validated during load,
    // but we add a diagnostic if it doesn't exist)
    if !config.plugin_root_abs.is_dir() {
        result.push(
            ValidationDiagnostic::error(format!(
                "Plugin root directory not found: {}",
                config.plugin_root_abs.display()
            ))
            .with_path(&config.marketplace_path)
            .with_field("pluginRoot"),
        );
    }

    // V2.6: No duplicate plugin names
    let mut seen_names = HashSet::new();
    for entry in &mp.plugins {
        if !seen_names.insert(&entry.name) {
            result.push(
                ValidationDiagnostic::error(format!(
                    "Duplicate plugin name: {}",
                    entry.name
                ))
                .with_path(&config.marketplace_path),
            );
        }
    }

    // V2.7 + V2.8: Each plugin entry has name and source
    for (i, entry) in mp.plugins.iter().enumerate() {
        if entry.name.is_empty() {
            result.push(
                ValidationDiagnostic::error(format!(
                    "Plugin entry {i} has empty name"
                ))
                .with_path(&config.marketplace_path)
                .with_field(format!("plugins[{i}].name")),
            );
        }
        if entry.source.is_empty() {
            result.push(
                ValidationDiagnostic::error(format!(
                    "Plugin entry {i} has empty source"
                ))
                .with_path(&config.marketplace_path)
                .with_field(format!("plugins[{i}].source")),
            );
        }
    }

    // V2.9 + V2.10: Completeness checks
    if config.plugin_root_abs.is_dir() {
        let completeness = check_completeness(config);
        result.merge(completeness);
    }

    // V2.11: Validate each listed plugin
    if !skip_plugins && config.plugin_root_abs.is_dir() {
        for entry in &mp.plugins {
            let source = &entry.source;
            let plugin_path = crate::resolution::resolve_source(source, config)
                .unwrap_or_else(|_| config.plugin_root_abs.join(source));

            if plugin_path.is_dir() {
                let plugin_result = validate_plugin(&plugin_path);
                result.merge(plugin_result);
            }
            // Missing directories are already caught by completeness check
        }
    }

    result
}

/// Check that filesystem and marketplace entries are in sync.
fn check_completeness(config: &MarketplaceConfig) -> ValidationResult {
    let mut result = ValidationResult::new();

    // Collect filesystem plugin directory names
    let fs_plugins: HashSet<String> = match std::fs::read_dir(&config.plugin_root_abs) {
        Ok(entries) => entries
            .flatten()
            .filter(|e| e.path().is_dir())
            .map(|e| e.file_name().to_string_lossy().to_string())
            .collect(),
        Err(_) => return result,
    };

    // Collect marketplace source basenames
    let mp_sources: HashSet<String> = config
        .marketplace
        .plugins
        .iter()
        .map(|p| {
            // Extract basename from source
            Path::new(&p.source)
                .file_name()
                .map(|n| n.to_string_lossy().to_string())
                .unwrap_or_else(|| p.source.clone())
        })
        .collect();

    // V2.9: Filesystem plugins not in marketplace (warning)
    for fs_name in &fs_plugins {
        if !mp_sources.contains(fs_name) {
            result.push(
                ValidationDiagnostic::warning(format!(
                    "Plugin in filesystem but not in marketplace: {fs_name}"
                ))
                .with_path(&config.plugin_root_abs.join(fs_name)),
            );
        }
    }

    // V2.10: Marketplace plugins not in filesystem (error)
    for mp_source in &mp_sources {
        if !fs_plugins.contains(mp_source) {
            result.push(
                ValidationDiagnostic::error(format!(
                    "Plugin in marketplace but not in filesystem: {mp_source}"
                ))
                .with_path(&config.marketplace_path),
            );
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::discovery::load_marketplace_config;
    use tempfile::TempDir;

    fn setup_marketplace(
        tmp: &TempDir,
        json: &str,
        plugin_dirs: &[&str],
    ) -> MarketplaceConfig {
        let claude = tmp.path().join(".claude-plugin");
        std::fs::create_dir_all(&claude).unwrap();
        let plugins = tmp.path().join("plugins");
        std::fs::create_dir_all(&plugins).unwrap();

        for name in plugin_dirs {
            let p = plugins.join(name).join(".claude-plugin");
            std::fs::create_dir_all(&p).unwrap();
            std::fs::write(
                p.join("plugin.json"),
                format!(r#"{{"name":"{name}","version":"1.0.0","description":"test"}}"#),
            )
            .unwrap();
        }

        std::fs::write(claude.join("marketplace.json"), json).unwrap();
        load_marketplace_config(&claude.join("marketplace.json")).unwrap()
    }

    #[test]
    fn valid_marketplace() {
        let tmp = TempDir::new().unwrap();
        let config = setup_marketplace(
            &tmp,
            r#"{"version":"0.1.0","pluginRoot":"./plugins","plugins":[{"name":"a","source":"a"}]}"#,
            &["a"],
        );
        let result = validate_marketplace(&config, false);
        assert!(!result.has_errors(), "diagnostics: {:?}", result.diagnostics);
    }

    #[test]
    fn invalid_version() {
        let tmp = TempDir::new().unwrap();
        let config = setup_marketplace(
            &tmp,
            r#"{"version":"bad","pluginRoot":"./plugins","plugins":[]}"#,
            &[],
        );
        let result = validate_marketplace(&config, true);
        assert!(result.has_errors());
    }

    #[test]
    fn duplicate_names() {
        let tmp = TempDir::new().unwrap();
        let config = setup_marketplace(
            &tmp,
            r#"{"version":"0.1.0","pluginRoot":"./plugins","plugins":[
                {"name":"a","source":"a"},{"name":"a","source":"b"}
            ]}"#,
            &["a", "b"],
        );
        let result = validate_marketplace(&config, true);
        assert!(result.has_errors());
        assert!(result.diagnostics.iter().any(|d| d.message.contains("Duplicate")));
    }

    #[test]
    fn completeness_filesystem_not_in_marketplace() {
        let tmp = TempDir::new().unwrap();
        let config = setup_marketplace(
            &tmp,
            r#"{"version":"0.1.0","pluginRoot":"./plugins","plugins":[]}"#,
            &["orphan"],
        );
        let result = validate_marketplace(&config, true);
        assert!(result.warning_count() > 0);
    }

    #[test]
    fn completeness_marketplace_not_in_filesystem() {
        let tmp = TempDir::new().unwrap();
        let config = setup_marketplace(
            &tmp,
            r#"{"version":"0.1.0","pluginRoot":"./plugins","plugins":[{"name":"missing","source":"missing"}]}"#,
            &[],
        );
        let result = validate_marketplace(&config, true);
        assert!(result.has_errors());
        assert!(result.diagnostics.iter().any(|d| d.message.contains("not in filesystem")));
    }

    #[test]
    fn skip_plugins_skips_individual_validation() {
        let tmp = TempDir::new().unwrap();
        // Plugin with invalid plugin.json
        let plugins = tmp.path().join("plugins");
        let bad = plugins.join("bad").join(".claude-plugin");
        std::fs::create_dir_all(&bad).unwrap();
        std::fs::write(bad.join("plugin.json"), "not json").unwrap();

        let claude = tmp.path().join(".claude-plugin");
        std::fs::create_dir_all(&claude).unwrap();
        std::fs::write(
            claude.join("marketplace.json"),
            r#"{"version":"0.1.0","pluginRoot":"./plugins","plugins":[{"name":"bad","source":"bad"}]}"#,
        )
        .unwrap();

        let config = load_marketplace_config(&claude.join("marketplace.json")).unwrap();
        let result = validate_marketplace(&config, true);
        // Should NOT have JSON parse errors because we skipped plugin validation
        assert!(!result.diagnostics.iter().any(|d| d.message.contains("Invalid JSON in plugin")));
    }

    #[test]
    fn empty_marketplace_is_valid() {
        let tmp = TempDir::new().unwrap();
        let config = setup_marketplace(
            &tmp,
            r#"{"version":"0.1.0","pluginRoot":"./plugins","plugins":[]}"#,
            &[],
        );
        let result = validate_marketplace(&config, true);
        assert!(!result.has_errors());
    }
}
```

**Step 2: Wire up module**

Update `crates/souk-core/src/validation/mod.rs`:

```rust
pub mod extends;
pub mod marketplace;
pub mod plugin;

pub use extends::validate_extends_plugin;
pub use marketplace::validate_marketplace;
pub use plugin::validate_plugin;
```

**Step 3: Run tests**

Run: `cargo test -p souk-core -- validation`
Expected: All validation tests pass.

**Step 4: Commit**

```bash
git add crates/souk-core/src/validation/
git commit -m "feat: add marketplace validation with completeness checks (V2.1-V2.11)"
```

---

### Task 9: Build Reporter (Output Abstraction)

**Files:**
- Create: `crates/souk/src/output.rs`
- Modify: `crates/souk/src/main.rs`

**Step 1: Write Reporter implementation**

Create: `crates/souk/src/output.rs`

```rust
use colored::*;
use serde::Serialize;
use souk_core::error::{Severity, ValidationDiagnostic, ValidationResult};
use std::io::Write;

/// Output mode for the CLI.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OutputMode {
    Human,
    Json,
    Quiet,
}

/// Accumulated JSON result entry.
#[derive(Debug, Serialize)]
pub struct JsonResultEntry {
    #[serde(rename = "type")]
    pub result_type: String,
    pub message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<String>,
}

/// Accumulated JSON output.
#[derive(Debug, Serialize)]
pub struct JsonOutput {
    pub results: Vec<JsonResultEntry>,
}

/// Reporter handles all output formatting.
pub struct Reporter {
    mode: OutputMode,
    json_results: Vec<JsonResultEntry>,
}

impl Reporter {
    pub fn new(mode: OutputMode) -> Self {
        Self {
            mode,
            json_results: Vec::new(),
        }
    }

    pub fn error(&mut self, message: &str) {
        match self.mode {
            OutputMode::Human => {
                eprintln!("{} {}", "ERROR:".red(), message);
            }
            OutputMode::Json => {
                self.json_results.push(JsonResultEntry {
                    result_type: "error".to_string(),
                    message: message.to_string(),
                    details: None,
                });
            }
            OutputMode::Quiet => {
                eprintln!("{} {}", "ERROR:".red(), message);
            }
        }
    }

    pub fn warning(&mut self, message: &str) {
        match self.mode {
            OutputMode::Human => {
                eprintln!("{} {}", "WARNING:".yellow(), message);
            }
            OutputMode::Json => {
                self.json_results.push(JsonResultEntry {
                    result_type: "warning".to_string(),
                    message: message.to_string(),
                    details: None,
                });
            }
            OutputMode::Quiet => {} // Suppress warnings in quiet mode
        }
    }

    pub fn success(&mut self, message: &str) {
        match self.mode {
            OutputMode::Human => {
                println!("{} {}", "✓".green(), message);
            }
            OutputMode::Json => {
                self.json_results.push(JsonResultEntry {
                    result_type: "success".to_string(),
                    message: message.to_string(),
                    details: None,
                });
            }
            OutputMode::Quiet => {} // Suppress success in quiet mode
        }
    }

    pub fn success_with_details(&mut self, message: &str, details: &str) {
        match self.mode {
            OutputMode::Human => {
                println!("{} {}", "✓".green(), message);
            }
            OutputMode::Json => {
                self.json_results.push(JsonResultEntry {
                    result_type: "success".to_string(),
                    message: message.to_string(),
                    details: Some(details.to_string()),
                });
            }
            OutputMode::Quiet => {}
        }
    }

    pub fn info(&mut self, message: &str) {
        match self.mode {
            OutputMode::Human => {
                println!("{} {}", "INFO:".blue(), message);
            }
            OutputMode::Json => {
                self.json_results.push(JsonResultEntry {
                    result_type: "info".to_string(),
                    message: message.to_string(),
                    details: None,
                });
            }
            OutputMode::Quiet => {}
        }
    }

    pub fn section(&mut self, title: &str) {
        if self.mode == OutputMode::Human {
            println!("{}", format!("=== {title} ===").cyan());
        }
    }

    /// Report all diagnostics from a ValidationResult.
    pub fn report_validation(&mut self, result: &ValidationResult) {
        for diagnostic in &result.diagnostics {
            let mut msg = diagnostic.message.clone();
            if let Some(path) = &diagnostic.path {
                msg = format!("{msg} ({path})", path = path.display());
            }
            match diagnostic.severity {
                Severity::Error => self.error(&msg),
                Severity::Warning => self.warning(&msg),
            }
        }
    }

    /// Flush JSON output if in JSON mode.
    pub fn finish(&self) {
        if self.mode == OutputMode::Json {
            let output = JsonOutput {
                results: self.json_results.clone(),
            };
            if let Ok(json) = serde_json::to_string_pretty(&output) {
                println!("{json}");
            }
        }
    }
}

impl Drop for Reporter {
    fn drop(&mut self) {
        // Ensure JSON is flushed even if finish() wasn't called explicitly
        if self.mode == OutputMode::Json && !self.json_results.is_empty() {
            // Only print if we haven't already flushed
            // (simple approach: don't auto-flush, require explicit finish())
        }
    }
}
```

**Step 2: Verify it compiles**

Run: `cargo build -p souk`
Expected: Compiles successfully.

**Step 3: Commit**

```bash
git add crates/souk/src/output.rs
git commit -m "feat: add Reporter output abstraction (human/json/quiet modes)"
```

---

### Task 10: Build CLI with Clap + Validate Commands

**Files:**
- Create: `crates/souk/src/cli.rs`
- Create: `crates/souk/src/commands/mod.rs`
- Create: `crates/souk/src/commands/validate.rs`
- Modify: `crates/souk/src/main.rs`

**Step 1: Define clap CLI structure**

Create: `crates/souk/src/cli.rs`

```rust
use clap::{Parser, Subcommand, ValueEnum};

#[derive(Parser, Debug)]
#[command(name = "souk", version, about = "Plugin marketplace management CLI")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,

    /// Output machine-readable JSON
    #[arg(long, global = true)]
    pub json: bool,

    /// Suppress non-error output
    #[arg(long, global = true)]
    pub quiet: bool,

    /// Color mode
    #[arg(long, global = true, default_value = "auto")]
    pub color: ColorMode,

    /// Path to marketplace.json (overrides auto-discovery)
    #[arg(long, global = true)]
    pub marketplace: Option<String>,
}

#[derive(Debug, Clone, ValueEnum)]
pub enum ColorMode {
    Auto,
    Always,
    Never,
}

#[derive(Subcommand, Debug)]
pub enum Commands {
    /// Validate plugins or marketplace
    Validate {
        #[command(subcommand)]
        target: ValidateTarget,
    },

    /// Add plugins to the marketplace
    Add {
        /// Plugin paths to add
        plugins: Vec<String>,

        /// Conflict resolution strategy
        #[arg(long, value_enum, default_value = "abort")]
        on_conflict: ConflictStrategy,

        /// Preview changes without executing
        #[arg(long)]
        dry_run: bool,

        /// Don't copy external plugins to pluginRoot
        #[arg(long)]
        no_copy: bool,
    },

    /// Remove plugins from the marketplace
    Remove {
        /// Plugin names to remove
        plugins: Vec<String>,

        /// Also delete plugin directory from disk
        #[arg(long)]
        delete: bool,
    },

    /// Update plugin metadata and bump version
    Update {
        /// Plugin names to update
        plugins: Vec<String>,

        /// Bump major version
        #[arg(long, group = "bump")]
        major: bool,

        /// Bump minor version
        #[arg(long, group = "bump")]
        minor: bool,

        /// Bump patch version
        #[arg(long, group = "bump")]
        patch: bool,
    },

    /// AI-powered review
    Review {
        #[command(subcommand)]
        target: ReviewTarget,
    },

    /// CI hook management
    Ci {
        #[command(subcommand)]
        action: CiAction,
    },

    /// Scaffold a new marketplace
    Init {
        /// Directory to create marketplace in
        #[arg(long)]
        path: Option<String>,

        /// Custom plugin root directory name
        #[arg(long, default_value = "./plugins")]
        plugin_root: String,
    },

    /// Generate shell completions
    Completions {
        /// Shell to generate completions for
        shell: clap_complete::Shell,
    },
}

#[derive(Subcommand, Debug)]
pub enum ValidateTarget {
    /// Validate one or more plugins
    Plugin {
        /// Plugin names or paths (omit for all)
        plugins: Vec<String>,
    },
    /// Validate the marketplace
    Marketplace {
        /// Skip validating individual plugins
        #[arg(long)]
        skip_plugins: bool,
    },
}

#[derive(Subcommand, Debug)]
pub enum ReviewTarget {
    /// Review a plugin
    Plugin {
        /// Plugin name or path
        plugin: String,
        #[arg(long)]
        output_dir: Option<String>,
        #[arg(long)]
        provider: Option<String>,
        #[arg(long)]
        model: Option<String>,
    },
    /// Review skills in a plugin
    Skill {
        /// Plugin name or path
        plugin: String,
        /// Skill names (comma-separated, omit for interactive)
        skills: Vec<String>,
        #[arg(long)]
        all: bool,
        #[arg(long)]
        output_dir: Option<String>,
        #[arg(long)]
        provider: Option<String>,
        #[arg(long)]
        model: Option<String>,
    },
    /// Review the entire marketplace
    Marketplace {
        #[arg(long)]
        output_dir: Option<String>,
        #[arg(long)]
        provider: Option<String>,
        #[arg(long)]
        model: Option<String>,
    },
}

#[derive(Subcommand, Debug)]
pub enum CiAction {
    /// Run CI validation
    Run {
        #[command(subcommand)]
        hook: CiHook,
    },
    /// Install CI integration
    Install {
        #[command(subcommand)]
        target: CiInstallTarget,
    },
}

#[derive(Subcommand, Debug)]
pub enum CiHook {
    /// Run pre-commit validation
    PreCommit,
    /// Run pre-push validation
    PrePush,
}

#[derive(Subcommand, Debug)]
pub enum CiInstallTarget {
    /// Install git hooks
    Hooks {
        /// Hook manager to use
        #[arg(long)]
        native: bool,
        #[arg(long)]
        lefthook: bool,
        #[arg(long)]
        husky: bool,
        #[arg(long)]
        overcommit: bool,
        #[arg(long)]
        hk: bool,
        #[arg(long)]
        simple_git_hooks: bool,
    },
    /// Install CI workflows
    Workflows {
        #[arg(long)]
        github: bool,
        #[arg(long)]
        blacksmith: bool,
        #[arg(long)]
        northflank: bool,
        #[arg(long)]
        circleci: bool,
        #[arg(long)]
        gitlab: bool,
        #[arg(long)]
        buildkite: bool,
    },
}

#[derive(Debug, Clone, ValueEnum)]
pub enum ConflictStrategy {
    Abort,
    Skip,
    Replace,
    Rename,
}
```

**Step 2: Wire up validate commands**

Create: `crates/souk/src/commands/validate.rs`

```rust
use std::path::PathBuf;

use souk_core::discovery::{discover_marketplace, load_marketplace_config, MarketplaceConfig};
use souk_core::resolution::resolve_plugin;
use souk_core::validation::{validate_marketplace, validate_plugin};

use crate::output::{OutputMode, Reporter};

pub fn run_validate_plugin(
    plugins: &[String],
    marketplace_override: Option<&str>,
    reporter: &mut Reporter,
) -> bool {
    // Try to load marketplace config (non-fatal if not found)
    let config = load_config(marketplace_override);

    let plugin_paths = collect_plugin_paths(plugins, config.as_ref(), reporter);

    if plugin_paths.is_empty() {
        reporter.error("No plugins found to validate");
        return false;
    }

    reporter.section(&format!("Validating {} plugin(s)", plugin_paths.len()));

    let mut success_count = 0;
    let mut failure_count = 0;

    for path in &plugin_paths {
        let plugin_name = path
            .file_name()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| path.display().to_string());

        let result = validate_plugin(path);

        if result.has_errors() {
            failure_count += 1;
            reporter.report_validation(&result);
        } else {
            success_count += 1;
            reporter.success_with_details(
                &format!("Plugin validated: {plugin_name}"),
                &format!("path: {}", path.display()),
            );
            // Still report warnings
            if result.warning_count() > 0 {
                reporter.report_validation(&result);
            }
        }
    }

    reporter.section("Summary");
    reporter.info(&format!(
        "{} plugin(s): {success_count} passed, {failure_count} failed",
        plugin_paths.len()
    ));

    failure_count == 0
}

pub fn run_validate_marketplace(
    skip_plugins: bool,
    marketplace_override: Option<&str>,
    reporter: &mut Reporter,
) -> bool {
    let config = match load_config_required(marketplace_override, reporter) {
        Some(c) => c,
        None => return false,
    };

    reporter.section("Validating marketplace");

    let result = validate_marketplace(&config, skip_plugins);

    reporter.report_validation(&result);

    if result.has_errors() {
        reporter.error("Marketplace validation failed");
        false
    } else {
        reporter.success("Marketplace validation passed");
        true
    }
}

fn load_config(marketplace_override: Option<&str>) -> Option<MarketplaceConfig> {
    let mp_path = if let Some(path) = marketplace_override {
        PathBuf::from(path)
    } else {
        let cwd = std::env::current_dir().ok()?;
        discover_marketplace(&cwd).ok()?
    };
    load_marketplace_config(&mp_path).ok()
}

fn load_config_required(
    marketplace_override: Option<&str>,
    reporter: &mut Reporter,
) -> Option<MarketplaceConfig> {
    let mp_path = if let Some(path) = marketplace_override {
        PathBuf::from(path)
    } else {
        let cwd = match std::env::current_dir() {
            Ok(c) => c,
            Err(e) => {
                reporter.error(&format!("Cannot get current directory: {e}"));
                return None;
            }
        };
        match discover_marketplace(&cwd) {
            Ok(p) => p,
            Err(e) => {
                reporter.error(&format!("{e}"));
                return None;
            }
        }
    };

    match load_marketplace_config(&mp_path) {
        Ok(c) => Some(c),
        Err(e) => {
            reporter.error(&format!("Failed to load marketplace: {e}"));
            None
        }
    }
}

fn collect_plugin_paths(
    plugins: &[String],
    config: Option<&MarketplaceConfig>,
    reporter: &mut Reporter,
) -> Vec<PathBuf> {
    let mut paths = Vec::new();

    if plugins.is_empty() {
        // Validate all plugins in pluginRoot
        let Some(config) = config else {
            reporter.error("No marketplace found and no plugins specified");
            return paths;
        };
        let plugin_root = &config.plugin_root_abs;
        if !plugin_root.is_dir() {
            reporter.error(&format!(
                "Plugin root directory not found: {}",
                plugin_root.display()
            ));
            return paths;
        }

        if let Ok(entries) = std::fs::read_dir(plugin_root) {
            for entry in entries.flatten() {
                if entry.path().is_dir() {
                    paths.push(entry.path());
                }
            }
        }
        paths.sort();
    } else {
        for input in plugins {
            let input_path = PathBuf::from(input);

            if input_path.is_dir() {
                // Check if it's a single plugin or directory of plugins
                if input_path.join(".claude-plugin").join("plugin.json").is_file() {
                    paths.push(input_path);
                } else {
                    // Directory of plugins
                    if let Ok(entries) = std::fs::read_dir(&input_path) {
                        for entry in entries.flatten() {
                            if entry.path().is_dir()
                                && entry
                                    .path()
                                    .join(".claude-plugin")
                                    .join("plugin.json")
                                    .is_file()
                            {
                                paths.push(entry.path());
                            }
                        }
                    }
                }
            } else {
                // Try plugin resolution
                match resolve_plugin(input, config) {
                    Ok(p) => paths.push(p),
                    Err(_) => {
                        reporter.error(&format!("Plugin not found: {input}"));
                    }
                }
            }
        }
    }

    paths
}
```

**Step 3: Create commands mod**

Create: `crates/souk/src/commands/mod.rs`

```rust
pub mod validate;
```

**Step 4: Update main.rs**

```rust
mod cli;
mod commands;
mod output;

use clap::Parser;
use cli::{Cli, ColorMode, Commands, ValidateTarget};
use output::{OutputMode, Reporter};

fn main() {
    let cli = Cli::parse();

    // Determine output mode
    let mode = if cli.json {
        OutputMode::Json
    } else if cli.quiet {
        OutputMode::Quiet
    } else {
        OutputMode::Human
    };

    // Configure colors
    match cli.color {
        ColorMode::Never => colored::control::set_override(false),
        ColorMode::Always => colored::control::set_override(true),
        ColorMode::Auto => {} // colored handles TTY detection
    }

    let mut reporter = Reporter::new(mode);
    let marketplace = cli.marketplace.as_deref();

    let success = match cli.command {
        Commands::Validate { target } => match target {
            ValidateTarget::Plugin { plugins } => {
                commands::validate::run_validate_plugin(&plugins, marketplace, &mut reporter)
            }
            ValidateTarget::Marketplace { skip_plugins } => {
                commands::validate::run_validate_marketplace(
                    skip_plugins,
                    marketplace,
                    &mut reporter,
                )
            }
        },
        _ => {
            reporter.error("Command not yet implemented");
            false
        }
    };

    reporter.finish();

    if !success {
        std::process::exit(1);
    }
}
```

**Step 5: Add clap_complete dependency**

Add to `crates/souk/Cargo.toml` under `[dependencies]`:
```toml
clap_complete = "4"
```

**Step 6: Verify it compiles and --help works**

Run: `cargo run -- --help`
Expected: Shows help with validate, add, remove, update, review, ci, init, completions subcommands.

Run: `cargo run -- validate --help`
Expected: Shows validate subcommands (plugin, marketplace).

**Step 7: Commit**

```bash
git add crates/souk/
git commit -m "feat: add CLI with clap, validate commands, and Reporter integration"
```

---

### Task 11: Create Test Fixtures + Integration Tests

**Files:**
- Create: `tests/fixtures/valid-marketplace/.claude-plugin/marketplace.json`
- Create: `tests/fixtures/valid-marketplace/plugins/good-plugin/.claude-plugin/plugin.json`
- Create: `tests/fixtures/valid-marketplace/plugins/good-plugin/skills/test-skill/SKILL.md`
- Create: `tests/fixtures/invalid-plugin/.claude-plugin/plugin.json`
- Create: `tests/integration/validate_test.rs`

**Step 1: Create valid marketplace fixture**

```bash
mkdir -p tests/fixtures/valid-marketplace/.claude-plugin
mkdir -p tests/fixtures/valid-marketplace/plugins/good-plugin/.claude-plugin
mkdir -p tests/fixtures/valid-marketplace/plugins/good-plugin/skills/test-skill
```

`tests/fixtures/valid-marketplace/.claude-plugin/marketplace.json`:
```json
{
  "version": "0.1.0",
  "pluginRoot": "./plugins",
  "plugins": [
    {
      "name": "good-plugin",
      "source": "good-plugin",
      "tags": ["test"]
    }
  ]
}
```

`tests/fixtures/valid-marketplace/plugins/good-plugin/.claude-plugin/plugin.json`:
```json
{
  "name": "good-plugin",
  "version": "1.0.0",
  "description": "A valid test plugin",
  "keywords": ["test"]
}
```

`tests/fixtures/valid-marketplace/plugins/good-plugin/skills/test-skill/SKILL.md`:
```markdown
---
name: test-skill
description: A test skill
---
# Test Skill
This is a test skill.
```

**Step 2: Create invalid plugin fixture**

```bash
mkdir -p tests/fixtures/invalid-plugin/.claude-plugin
```

`tests/fixtures/invalid-plugin/.claude-plugin/plugin.json`:
```json
{
  "name": null,
  "version": "not-semver"
}
```

**Step 3: Write integration tests**

Create: `tests/integration/validate_test.rs`

```rust
use assert_cmd::Command;
use predicates::prelude::*;
use std::path::PathBuf;

fn fixtures_dir() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .join("tests")
        .join("fixtures")
}

#[test]
fn validate_valid_plugin_by_path() {
    let plugin = fixtures_dir()
        .join("valid-marketplace")
        .join("plugins")
        .join("good-plugin");

    Command::cargo_bin("souk")
        .unwrap()
        .args(["validate", "plugin", plugin.to_str().unwrap()])
        .assert()
        .success()
        .stdout(predicate::str::contains("Plugin validated: good-plugin"));
}

#[test]
fn validate_invalid_plugin_by_path() {
    let plugin = fixtures_dir().join("invalid-plugin");

    Command::cargo_bin("souk")
        .unwrap()
        .args(["validate", "plugin", plugin.to_str().unwrap()])
        .assert()
        .failure()
        .stderr(predicate::str::contains("ERROR:"));
}

#[test]
fn validate_marketplace_valid() {
    let mp = fixtures_dir()
        .join("valid-marketplace")
        .join(".claude-plugin")
        .join("marketplace.json");

    Command::cargo_bin("souk")
        .unwrap()
        .args([
            "validate",
            "marketplace",
            "--marketplace",
            mp.to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout(predicate::str::contains("Marketplace validation passed"));
}

#[test]
fn validate_plugin_json_output() {
    let plugin = fixtures_dir()
        .join("valid-marketplace")
        .join("plugins")
        .join("good-plugin");

    let output = Command::cargo_bin("souk")
        .unwrap()
        .args([
            "validate",
            "plugin",
            plugin.to_str().unwrap(),
            "--json",
        ])
        .output()
        .unwrap();

    assert!(output.status.success());
    let stdout = String::from_utf8(output.stdout).unwrap();
    let parsed: serde_json::Value = serde_json::from_str(&stdout).unwrap();
    assert!(parsed["results"].is_array());
}

#[test]
fn validate_nonexistent_plugin() {
    Command::cargo_bin("souk")
        .unwrap()
        .args(["validate", "plugin", "/tmp/nonexistent-souk-test-xyz"])
        .assert()
        .failure();
}
```

**Step 4: Run integration tests**

Run: `cargo test --test validate_test`
Expected: All integration tests pass.

**Step 5: Commit**

```bash
git add tests/
git commit -m "feat: add test fixtures and integration tests for validate commands"
```

---

## Phase 2: Plugin Management (Stories 5, 6, 7, 8)

### Task 12: Implement AtomicGuard (RAII Backup/Restore)

**Files:**
- Create: `crates/souk-core/src/ops/mod.rs`
- Create: `crates/souk-core/src/ops/atomic.rs`
- Modify: `crates/souk-core/src/lib.rs`

**Step 1: Write AtomicGuard with tests**

Create `crates/souk-core/src/ops/atomic.rs` implementing:
- `AtomicGuard::new(path)` — creates timestamped backup
- `AtomicGuard::commit()` — removes backup (success path)
- `Drop` implementation — restores backup if not committed
- Unit tests: backup creation, commit removes backup, drop restores, nested guards

**Step 2: Run tests, commit**

---

### Task 13: Implement Version Bumping

**Files:**
- Create: `crates/souk-core/src/version.rs`
- Modify: `crates/souk-core/src/lib.rs`

**Step 1: Write version bump functions with tests**

Implement:
- `bump_major(version: &str) -> Result<String>`
- `bump_minor(version: &str) -> Result<String>`
- `bump_patch(version: &str) -> Result<String>`
- `generate_unique_name(base: &str, existing: &HashSet<String>) -> String`

**Step 2: Run tests, commit**

---

### Task 14: Implement Init Command

**Files:**
- Create: `crates/souk-core/src/ops/init.rs`
- Create: `crates/souk/src/commands/init.rs`
- Modify: `crates/souk/src/commands/mod.rs`
- Modify: `crates/souk/src/main.rs`

**Step 1: Write init logic with tests**

Implement `scaffold_marketplace(path, plugin_root)`:
- Create `.claude-plugin/marketplace.json` with version `0.1.0`, pluginRoot, empty plugins
- Create plugin root directory
- Error if marketplace already exists

**Step 2: Wire to CLI, write integration test, commit**

---

### Task 15: Implement Add Command (7-Phase Pipeline)

**Files:**
- Create: `crates/souk-core/src/ops/add.rs`
- Create: `crates/souk/src/commands/add.rs`
- Modify: `crates/souk/src/commands/mod.rs`
- Modify: `crates/souk/src/main.rs`

**Step 1: Implement plan_add() returning AddPlan struct**

The `AddPlan` captures all operations to perform without executing them.

**Step 2: Implement execute_add() consuming an AddPlan**

7 phases: preflight → plan → dry-run → copy → atomic update → version bump → final validation.

**Step 3: Implement all 4 conflict strategies (abort/skip/replace/rename)**

**Step 4: Write integration tests for each conflict strategy and rollback**

**Step 5: Commit**

---

### Task 16: Implement Remove Command

**Files:**
- Create: `crates/souk-core/src/ops/remove.rs`
- Create: `crates/souk/src/commands/remove.rs`

**Step 1: Implement remove_plugins(names, delete_files, config)**

- Find each name in marketplace.json `.plugins[]`
- Remove entries atomically (with AtomicGuard)
- If `--delete`: remove plugin directory from disk
- Bump marketplace version

**Step 2: Write tests, wire to CLI, commit**

---

### Task 17: Implement Update Command

**Files:**
- Create: `crates/souk-core/src/ops/update.rs`
- Create: `crates/souk/src/commands/update.rs`

**Step 1: Implement update_plugins(names, bump_type, config)**

- Re-read plugin.json from disk
- Update marketplace entry (name, tags, source)
- Bump version in plugin.json based on `--major/--minor/--patch`
- If no bump flag: compare metadata and suggest bump type
- Re-validate plugin
- Bump marketplace version

**Step 2: Write tests, wire to CLI, commit**

---

## Phase 3: Review Commands (Stories 9, 10, 11)

### Task 18: Implement LLM Provider Abstraction

**Files:**
- Create: `crates/souk-core/src/review/mod.rs`
- Create: `crates/souk-core/src/review/provider.rs`
- Modify: `crates/souk-core/Cargo.toml` (add reqwest)

**Step 1: Define LlmProvider trait**

```rust
#[async_trait]
pub trait LlmProvider: Send + Sync {
    async fn complete(&self, prompt: &str) -> Result<String, SoukError>;
    fn name(&self) -> &str;
    fn model(&self) -> &str;
}
```

**Step 2: Implement AnthropicProvider, OpenAiProvider, GeminiProvider**

Each reads API key from environment, sends HTTP request to the respective API, returns completion text.

**Step 3: Implement provider auto-detection**

Check ANTHROPIC_API_KEY → OpenAI → Gemini. First found wins. `--provider` flag overrides.

**Step 4: Implement MockProvider for tests**

**Step 5: Write tests, commit**

---

### Task 19: Implement Review Plugin Command

**Files:**
- Create: `crates/souk-core/src/review/plugin.rs`
- Create: `crates/souk/src/commands/review.rs`

**Step 1: Implement review_plugin(plugin_path, provider, output_dir)**

- Read all plugin files into a structured prompt
- Send to LLM API
- Save response to `{output_dir}/review-report.md`
- Return metadata (provider, model, date, path)

**Step 2: Wire to CLI, write tests with MockProvider, commit**

---

### Task 20: Implement Review Skill Command

**Files:**
- Create: `crates/souk-core/src/review/skill.rs`

**Step 1: Implement review_skill with interactive selection**

- Enumerate skills (Task 6)
- If no skill specified and interactive: present numbered menu
- Parse selection (single, comma-separated, range, "all")
- Review each selected skill
- Save per-skill reports

**Step 2: Wire to CLI, write tests, commit**

---

### Task 21: Implement Review Marketplace Command

**Files:**
- Create: `crates/souk-core/src/review/marketplace.rs`

**Step 1: Implement review_marketplace(config, provider, output_dir)**

- Read marketplace.json + all plugin manifests
- Build structured prompt for marketplace-level review
- Save report

**Step 2: Wire to CLI, write tests, commit**

---

## Phase 4: CI Commands (Stories 12, 13, 14, 15)

### Task 22: Implement Pre-Commit Hook

**Files:**
- Create: `crates/souk-core/src/ci/mod.rs`
- Create: `crates/souk-core/src/ci/hooks.rs`
- Create: `crates/souk/src/commands/ci.rs`

**Step 1: Implement detect_changed_plugins(config)**

- Run `git diff --cached --name-only`
- Parse staged paths against `{pluginRoot_relative}/{name}/...` pattern
- Return deduplicated plugin names

**Step 2: Implement run_pre_commit(config)**

- Get changed plugins
- Validate only those plugins
- If marketplace.json is staged, validate marketplace with `--skip-plugins`

**Step 3: Wire to CLI, write tests, commit**

---

### Task 23: Implement Pre-Push Hook

**Step 1: Implement run_pre_push(config)**

- Run full `validate_marketplace(config, false)`
- On failure, suggest `git push --no-verify`

**Step 2: Wire to CLI, write tests, commit**

---

### Task 24: Implement Hook Installation

**Files:**
- Create: `crates/souk-core/src/ci/install_hooks.rs`

**Step 1: Implement hook manager detection**

Auto-detect: lefthook.yml, .husky/, .overcommit.yml, hk.toml, .simple-git-hooks.json.

**Step 2: Implement install for each of the 6 managers**

Each generates the appropriate config format calling `souk ci run pre-commit` / `pre-push`.

**Step 3: Wire to CLI, write tests, commit**

---

### Task 25: Implement Workflow Installation

**Files:**
- Create: `crates/souk-core/src/ci/install_workflows.rs`

**Step 1: Implement CI provider detection**

Auto-detect: .github/workflows/, .circleci/, .gitlab-ci.yml, .buildkite/.

**Step 2: Implement workflow templates for each of the 6 providers**

Each generates the appropriate CI config file.

**Step 3: Wire to CLI, write tests, commit**

---

## Phase 5: Distribution & Polish (Story 16)

### Task 26: Shell Completions + Man Pages

**Files:**
- Modify: `crates/souk/src/main.rs`
- Modify: `crates/souk/Cargo.toml`

**Step 1: Implement completions subcommand**

Wire `clap_complete::generate()` for bash/zsh/fish to stdout.

**Step 2: Add clap_mangen build step**

Generate man pages in `build.rs`.

**Step 3: Commit**

---

### Task 27: Progress Bars for Batch Operations

**Step 1: Add indicatif progress bars**

Wrap batch validation and batch review loops with `ProgressBar`.

**Step 2: Commit**

---

### Task 28: Cross-Platform CI

**Files:**
- Create: `.github/workflows/ci.yml`
- Create: `.github/workflows/release.yml`

**Step 1: CI workflow for testing**

Matrix: ubuntu-latest, macos-latest, windows-latest. Steps: cargo test, cargo clippy, cargo fmt --check.

**Step 2: Release workflow**

On tag push, build binaries for 5 targets using `cross`, upload as GitHub release assets.

**Step 3: Commit**

---

### Task 29: Final Integration Test Suite

**Step 1: End-to-end tests**

Test the full lifecycle:
1. `souk init` → creates marketplace
2. `souk validate marketplace` → passes on empty marketplace
3. Create a plugin on disk
4. `souk add ./plugin` → adds to marketplace
5. `souk validate plugin` → passes
6. `souk update plugin --patch` → bumps version
7. `souk remove plugin` → removes from marketplace

**Step 2: Snapshot tests with insta**

Capture human output and JSON output for all commands.

**Step 3: Commit**

---

## Summary

| Phase | Tasks | Stories Covered |
|-------|-------|-----------------|
| 1: Workspace & Core Types | 1–11 | 1, 2, 3, 4 |
| 2: Plugin Management | 12–17 | 5, 6, 7, 8 |
| 3: Review Commands | 18–21 | 9, 10, 11 |
| 4: CI Commands | 22–25 | 12, 13, 14, 15 |
| 5: Distribution | 26–29 | 16 |

**Total tasks: 29**

Tasks 1–11 are fully specified with complete code. Tasks 12–29 follow the same TDD pattern but are described at a higher level since their implementation details depend on patterns established in Phase 1. Each should be fully expanded before execution using the same step-by-step format.
